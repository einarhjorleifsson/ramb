% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dc_split_among_pings.R
\name{dc_split_among_pings}
\alias{dc_split_among_pings}
\title{Distribute logbook catch/value among VMS pings using dplyr}
\usage{
dc_split_among_pings(
  tacsat,
  eflalo,
  level = c("trip", "ICESrectangle", "day"),
  by = NULL,
  variable = "all"
)
}
\arguments{
\item{tacsat}{Data frame of VMS pings (see Required columns).}

\item{eflalo}{Data frame of logbook trips (see Required columns).}

\item{level}{Character vector; hierarchical grouping for splitting, must be one of:
c("trip"), c("trip", "ICESrectangle"), or c("trip", "ICESrectangle", "day").}

\item{by}{Optional; name of a `tacsat` column to use as weight for splitting (e.g., "INTV"). If NULL (default), splits equally.}

\item{variable}{Which variable(s) to split: "all" (default), "value", or "kgs".}
}
\value{
Tibble/data.frame of fishing pings with assigned catch/value columns (`KG`, `EURO`).
}
\description{
This function distributes logbook-reported catch and/or value among relevant VMS pings (fishing pings) using `dplyr`.
It mimics the logic of `vmstools::splitAmongPings` but is implemented with `dplyr` and `lubridate`.
}
\details{
It links VMS ping data (`tacsat`) with logbook trip data (`eflalo`) and distributes reported catch/value across the relevant VMS pings, optionally weighted by a specified column (e.g., time interval).

Splitting is always hierarchical and must be one of the following (from coarsest to finest):
  - `level = c("trip")`
  - `level = c("trip", "ICESrectangle")`
  - `level = c("trip", "ICESrectangle", "day")`
Only these three forms are allowed.
Only fishing pings (`SI_STATE == 1`) receive catch/value.

## Required columns

**tacsat** (VMS pings):  
- `SI_STATE` (integer: 1 = fishing, 0 = not fishing; only 1 or 0 allowed)  
- `SI_DATIM` (datetime; POSIXct)  
- `VE_REF`, `FT_REF` (character; vessel/trip identifiers)  
- `LE_RECT` (character; ICES rectangle)  
- (optional: weighting column, e.g., `INTV`)

**eflalo** (logbook trips):  
- `FT_REF`, `VE_REF` (character; must match tacsat)  
- `LE_CDAT` (date; trip date, format: "dd/mm/yyyy" or POSIXct)  
- `LE_RECT` (character; ICES rectangle)  
- `LE_KG` (numeric; catch in kg)  
- `LE_EURO` (numeric; value in euro)

## Returned value

Returns a tibble/data.frame of pings (rows from `tacsat`), with columns:
- All columns from input `tacsat` (except for temporary columns and grouping variables)
- `KG`: assigned catch (kg) per ping (numeric; 0 if not assigned)
- `EURO`: assigned value (€) per ping (numeric; 0 if not assigned)

## Details

- Performs a left join between `tacsat` and `eflalo` on grouping columns based on `level` (hierarchical).
- For each group (e.g., trip, rectangle, day), splits catch/value among fishing pings, either equally or weighted by the `by` column.
- Only pings with `SI_STATE == 1` will be assigned catch/value.
- `SI_STATE` must only contain values 0 or 1; an error is thrown otherwise.
- No "conserve" logic: only matched pings receive catch/value.
- Date columns must be "dd/mm/yyyy" or POSIXct; time columns not used directly.
- Only `dplyr`, `lubridate`, and base R are used.
}
\examples{
library(dplyr); library(lubridate)
eflalo <- tibble(
  VE_COU = rep("ISL", 4),
  VE_REF = rep("V001", 4),
  FT_REF = rep("1", 4),
  LE_CDAT = c("01/01/2025", "01/01/2025", "02/01/2025", "02/01/2025"),
  LE_RECT = c("32F1", "32F2", "32F3", "32F2"),
  LE_KG = c(100, 500, 1200, 300),
  LE_EURO = c(100, 500, 1200, 300)
)
tacsat <- tibble(
  SI_DATIM = seq(ymd_hms("2025-01-01 06:00:00"), ymd_hms("2025-01-02 18:00:00"), by = "1 hour")
) \%>\%
  mutate(
    VE_COU = "ISL",
    VE_REF = "V001",
    FT_REF = "1",
    LE_RECT = case_when(
      between(SI_DATIM, ymd_hms("2025-01-01 09:00:00 UTC"), ymd_hms("2025-01-01 13:00:00 UTC")) ~ "32F1",
      between(SI_DATIM, ymd_hms("2025-01-01 18:00:00 UTC"), ymd_hms("2025-01-01 21:00:00 UTC")) ~ "32F2",
      between(SI_DATIM, ymd_hms("2025-01-02 02:00:00 UTC"), ymd_hms("2025-01-02 03:00:00 UTC")) ~ "32F3",
      between(SI_DATIM, ymd_hms("2025-01-02 13:00:00 UTC"), ymd_hms("2025-01-02 14:00:00 UTC")) ~ "32F2",
      TRUE ~ "9999"
    ),
    SI_STATE = 1L,
    INTV = 1
  ) \%>\%
  mutate(.rowid = 1:n(), .before = SI_DATIM)
# Test hierarchical forms
result1 <- dc_split_among_pings(
  tacsat = tacsat,
  eflalo = eflalo,
  variable = "all",
  level = c("trip", "ICESrectangle", "day"),
  by = "INTV"
)
result2 <- dc_split_among_pings(
  tacsat = tacsat,
  eflalo = eflalo,
  variable = "all",
  level = c("trip", "ICESrectangle"),
  by = "INTV"
)
result3 <- dc_split_among_pings(
  tacsat = tacsat,
  eflalo = eflalo,
  variable = "all",
  level = c("trip"),
  by = "INTV"
)
# All SI_STATE must be 0 or 1:
stopifnot(all(result1$SI_STATE \%in\% c(0,1)))
stopifnot(all(result2$SI_STATE \%in\% c(0,1)))
stopifnot(all(result3$SI_STATE \%in\% c(0,1)))
# head(result1); head(result2); head(result3)

}
\author{
Einar Hjörleifsson
}
